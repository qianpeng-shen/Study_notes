正则表达式：最难的地方是剔除不需要匹配的信息，
而不是匹配不到想要的信息；

匹配电子邮件的史上最复杂正则：
	(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\
	\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\]
	!(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\
	\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])

参考：
	https://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html

贪婪模式：.*_
懒惰模式: .*?_

在匹配网页信息的时候比较适合的方式是：
    使用懒惰的模式，使用勤劳的态度(findall)获取所有
应该抓取到的信息；
用正则匹配：
   URL,Email,中文字符,QQ号参见保存的文件；

万能的正则表达式：
		([\s\S]*?)	

作业：
	1）使用正则表达式实现下面的效果：
把 i=d%0A&from=AUTO&to=AUTO&smartresult=dict
转换成下面的形式：
i:d%0A
from:AUTO
to:AUTO
smartresult:dict
  2）把一个文件夹下面的文件，
拷贝到另一个文件夹下面；（要求：
1.使用多进程(进程池)或者多线程(线程池)来完成；
2.怎么证明拷贝的文件是完整的；
3.这个文件夹下的文件不能少于1000个，
文件的类型需要多元化，有图片，有视频，有二进制文件
4.可以加入进度条的考虑；
5.不要求今天完成，可以在第三天完成作业
）；

面试题：
    有1000个一模一样的瓶子，
其中有999个装的是普通的水，
有一瓶装的是无色无味的毒药；
这瓶毒药在小白鼠喝完之后一周就会发作死亡；
你有10只小白鼠和一周的时间。
请问如何找到这瓶毒药？
1-1000：
	1       0000000001
	2       0000000010
	3       0000000011
	4       0000000100
	5       0000000101
	。。。
	889     1101111001
	1000    1111101000
mouse：
	m1,m2,m3,m4,m5,m6,m7,m8,m9,m10
   1 1  0   1  1  1  1  0  0  1

CPython
Python的多进程，多线程：
		1)单核情况下，有一个线程，
		    while True:
					pass
		CPU占用率几乎100%
		2)双核情况下，有两个线程(进程)，
		    while True:
					pass
		CPU占用率几乎50%(100%)

GIL全局解释锁：
   最初是为了适应单核年代，性能不是问题，同时由于
GIL的存在，数据更加安全；
   但是到了多核的年代，由于GIL的存在，
成了性能的瓶颈；Python为了应对这个问题，
提倡我们使用multiprocessing中的Process类;

Python多进程的使用场景：计算密集型的场景，比如
解密，科学计算，图像处理，机器学习等等；
Python多线程的使用场景：IO密集型的场景，爬虫，
网络下载程序；
进程的是CPU分配资源的单位，
线程是真正的执行流程，协程是轻量级的线程；
进程池之间通信的时候，需要使用Manager；
	from multiprocessing import Manager

装饰函数的应用：
		import functools #函数的包装器
    newCrawlPage = functools.partial(CrawlPage, lock)
    

