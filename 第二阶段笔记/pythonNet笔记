吕泽
lvze@tedu.com.cn

网络----->进程线程---->web服务器
mongo---->regex----->项目

互联网---> 　网络传输数据

ISO(国际标准化组织)---->  网络体系结构标准 OSI模型

OSI  七层模型

应用层: 提供用户服务，具体内容由特定程序规定

表示层: 提供数据的压缩解压和加密等

会话层: 建立程序级的连接，决定使用什么样的传输服务

传输层: 提供合适的通信服务，流量的控制

网络层:　路由选择，网络互联，分组传输

链路层:　提供链路交换，具体消息发送

物理层: 物理硬件，接口

OSI　模型优点　: 将功能分开，降低网络传输中的耦合度，每一部分完成自己的功能，开发更加清晰。

高内聚：使模块功能单一，不混杂。
低耦合：模块之间尽量减少相互的关联和影响

实际应用一般是　四层，五层模型

四层模型

应用层：应用层　表示层　会话层

传输层：传输层

网络层：网络层

物理链路层：链路层　物理层

五层模型(TCP/IP模型)

应用层：应用层　表示层　会话层

传输层：传输层

网络层：网络层

链路层：链路层　

物理层：物理层

要求：能够顺序说出七层模型，知道如何对应四层或五层模型，简单理解每一层的功能，能理解数据传输过程

什么是协议

网络协议：网络通信中，各方必须遵守的规定，包括建立什么连接，如何识别，消息结构等

应用层协议：TFTP HTTP　SMTP DNS 

传输层协议： TCP UDP 

网络层协议：IP 


网络概念

主机：计算机的名称　　
　　　　　localhost(表示本机)



ipython3  
In [2]: import socket
获取主机名
In [3]: socket.gethostname()
Out[3]: 'tedu'

获取主机名解析IP
In [9]: socket.gethostbyname("tedu")
Out[9]: '127.0.1.1'

In [10]: socket.gethostbyname("localhost")
Out[10]: '127.0.0.1'

IP 
IPV4:192.168.1.2　　点分时十进制：三个点分为四个部分：0~255

IPV6: ip地址更多

127.0.0.1:本地测试ip

0.0.0.0:局域网可用ip

192.168.1.0:表示网段
192.168.1.1:网关
192.168.1.255: 广播地址


ifconfig  ping   

In [6]: socket.gethostbyaddr('www.baidu.com')
Out[6]: ('127.0.0.1',  [], ['119.75.216.20'])
          主机名      别名   IP

将IP地址转换为二进制
In [7]: socket.inet_aton('192.168.1.2')
Out[7]: b'\xc0\xa8\x01\x02'

将二进制转换为点分十进制
In [8]: socket.inet_ntoa(b'\xc0\xa8\x01\x02')
Out[8]: '192.168.1.2'


inet_pton inet_ntop 功能同上　只是第一个参数用
socket.AF_IENT表示IPv4   socket.AF_IENT6表示IPv6

端口号
端口号是地址的组成部分，在一个系统中区分应用层程序
1~65535: 1~255 众所周知的端口　　256~1023 系统端口
推荐大于10000的端口

In [4]: socket.inet_aton('192.168.1.2')
Out[4]: b'\xc0\xa8\x01\x02'

In [6]: socket.inet_ntoa(b'\xc0\xa8\x01\x02')
Out[6]: '192.168.1.2'

获取一个应用的端口
In [7]: socket.getservbyname('mysql')
Out[7]: 3306

子网掩码　：和IP配合过滤网段　
dns：域名解析　　域名就是IP

字节序
大端序：高字节存在低地址
小端序：低字节存在低地址

网络字节序：将字节序发送方式统一



传输层服务


tcp协议

面向连接　(的通信服务)------>可靠的数据传输

三次握手
１．客户端向服务器发起连接请求(问是否可以连接)
２．服务区接收到请求后进行确认(允许连接)　返回报文
３．客户端收到许可，建立连接

四次挥手
１．主动方发送报文告知被动方要断开连接
２．被动方返回报文，告知收到请求，准备断开
３．被动方发送报文给主动方告知准备就绪可以断开
４．主动方发送报文确定断开


可靠传输：无失序　无差错　无丢失　无重复

应用情况：　适用于传输内容较大，网络情况好，需要提供准确传输的情况　
比如：聊天信息，文件传输，邮件


udp协议

面向无连接的服务----->不可靠

发送时有发送端自主进行，不考虑接收端

应用情况：适用于网络较差，对传输准确性要求低，广播传播
比如：视频会议，广播数据


套接字编程

套接字：进行网络通信的一种手段 socket

流式套接字(SOCK_STREAM)：　传输层基于tcp协议进行通信

数据报套接字(SOCK_DGRAM)：传输层基于udp协议进行通信

原始套接字(SOXK_RAM)：访问底层协议的套接字

TCP 服务端
from socket  import *

1. 创建套接字
socket(socket_family=AF_INET,
             socket_type=SOCK_STREAM,
             proto = 0)
功能 ： 创建套接字
参数 ： socket_family：选择地址族种类 AF_INET (UNIX)
       socket_type ： 套接字类型SOCK_STREAM 流式 
                                      SOCK_DGRAM 数据报
                proto ：子协议类型默认为0
返回值 ： 返回创建的套接字 

2. 绑定 IP 和端口号

sockfd.bind()
功能 ： 绑定IP和端口
参数 ： 是一个元组 ，第一项是字符串形式的IP
                     第二项是端口号
                （‘192.168.1.2’，8888）

3. 让套接字具有监听功能
sockfd.listen(n)
功能 ： 使套接字变为监听套接字，同时创建监听队列
参数 ： n 监听队列大小

4. 等待客户端连接
sockfd.accept()
功能 ： 阻塞等待客户端连接
返回值 ： 第一个：返回一个新的套接字用来和客户端通信
                    第二个：返回连接的客户端的地址

5. 消息的收发
recv（buffer）
功能 ： 接收消息
参数 ： 一次接收消息的大小  字节
返回值： 接收到的内容

send（data）
功能： 发送消息
参数： 发送的内容  （byte）
返回值 ： 发送了多少个字节

* 当没有接收端的时候send操作会导致 broken pipe

6. 关闭套接字
close（）
功能 ： 关闭套接字

tcp客户端流程

1.创建流式套接字
2.发起连接请求
connect（）
功能：发起连接
参数 ： 一个元组  第一个元素 ： 服务器的IP
                  第二个元素 ： 服务器的port

3.收发消息
4.关闭套接字


**** 如何让一个服务器处理多个客户端任务 ****

练习 
1. 什么是网络七层模型，每一层什么功能。tcp/ip模型又是什么
2. 简述三次握手和四次挥手的过程

3. 使用tcp完成一个简单的对话交互



day02

#关于recv和send
发送接收缓冲区
*发送和接收消息均先放到缓冲区再进行处理
*接收消息当一次接受不完的时候　，下次会继续接受
*当recv阻塞时，如果客户端断开，则recv立即返回空字符串

#TCP粘包处理
tcp中的数据以数据流的方式发送接收，每次发送的数据间没有边界，在接收时可能造成数据的粘连即为粘包

粘包如何处理：
１．每次发送消息结束位置加标志
２．发送的消息添加结构描述
３．当连续发送时每次发送有一个短暂延迟 sleep(0.1)


udp通信
１．创建数据报套接字
sockfd=socket(AF_INET,SOCK_DGRAM)
２．绑定服务端地址
ADDR=('192.168.1.2',8888)
sockfd.bind(ADDR)
３．收发消息
收消息
data,addr=recvfrom(buffersize)单位字节

功能：接收数据包套接字消息
参数:每次最多接受消息的大小(字节)
返回值：　data: 接data的消息
　　　　　　　addr:消息发送者的地址
发消息
sendto(data,addr)

*revefrom一次接受一个数据包，如果数据包一次没有接收完则会丢失没接收的内容
功能：发送消息
参数：data　要发送的消息
　　　　　addr 发送给某一个主机的地址
返回值：发送消息的字节数

4.关闭套接字
close()


sys.argv:自动收集命令行内容为一个列表


tcp 和 udp　的区别
１．tcp传输数据使用字节流的方式传输，udp时数据包
２．tcp会产生粘包现象，udp不会
３．tcp对网络条件高，udp更合适实时传输　
４．tcp编程可以保证传输的可靠性，udp则不保证
５．tcp使用listen　accept, udp不需要
６．收发消息tcp使用 recv send sendall              
          udp使用 recvfrom sendto

补充：　sendall() 用法同send()
      发送成功返回None,失败产生异常

------------------------------------------------

套接字属性
from socket import *
s=socket()
s.fileno()
功能：获取套接字的描述符
s.type
功能：获得套接字类型
*描述符：每一个IO操作系统都会分配一个不同的整数与只对应，该整数即为此IO操作的描述符

s.getsockname()
功能：获取套接字绑定的地址

s.getpeername()
功能：使用accept生成的套接字调用，获得给该套接字对应的客户端地址

s.setsockopt(level,optname,value)
功能：设置套接字选项
参数：level:要定义的选项类型  可选值---> IPPROTO_TCP IPPROTP_IP SOL_SOCKET
     optname:根据level确定的子选项
     value:根据选项设置的值
示例：s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)

s.getsockopt(level,optname)
功能：获取套接字选项
参数：同setsockopt
返回值：返回相应选项的值


udp应用之广播
要将套接字设置为允许接收广播
将消息发送给局域网所有终端
172.60.50.255

广播风暴：在一个网络中大量发送广播会占用大量带宽

tcp应用值http传输


HTTP协议　(超文本传输协议)

１．客户端(浏览器)　发起http请求
２．传输层使用tcp协议建立连接，层层打包将请求内容发送给服务器
３．web服务区解包后解析http请求,交给后端应用程序处理
４．后端应用得到结果，通过web服务器返回发送给前端

用途：网站中网页的传输和数据传输
　　　　　也可用作基于http协议的编程传输数据

特点：　应用层此协议，传输层使用tcp连接
　　　　　　简单，灵活，接口使用方便
　　　　　　几乎支持所有的数据类型
　　　　　　是无状态的协议
　　　　　　http1.1版本　持续连接

请求(request)
格式：

请求行：确定具体的请求类型
请求头：请求内容的信息描述
空行
请求正文：具体请求参数

请求行：　GET 　　　　　/index.html  HTTP/1.1
        请求方法　　请求资源　　　　　　协议版本

请求方法：GET(常用)  　获取网络资源
        POST(常用)　　提交一定的附加数据，得到返回结果
        HEAD　　　　　　　获取响应的头信息
        PUT　　　　　　　　更新服务器的资源
        DELETE　　　　　删除服务器资源
        TRACE　　　　　　用于测试
        CCONNECT　　　保留方法
        OPTIONS　　　　请求获取服务器性能和信息
前四条常用
请求体：
get请求----> get 参数　&a=1&b=2
post请求---> post　提交的内容


响应(response)

格式：

响应行　　　　反馈响应的情况
响应头　　　　对响应的具体描述
空行
响应体　　　　具体返回给用户的内容

响应行　：　HTTP/1.1 　200 　　　　OK
        协议版本　　　　响应码　　　信息
响应码：
1xx  ：提示信息，表示请求已经接收，正在处理
2xx　　：请求响应成功
3xx　　：重定向，完成任务需要其他操作
4xx　　：客户端错误
5xx　　：服务端错误

200 　成功
401 　没有访问权限
404 　资源不存在
500 　服务器发生未知错误
503 　服务器暂时无法执行

响应头　格式同请求头

响应体：　文件，图片......


要求：　能够简述一个网站的流程
　　　　　　知道什么是http协议及基本特点
　　　　　　知道http请求种类，及每种请求的功能
　　　　　　知道http响应种类及常见的响应码
　　　　　　知道get请求和post请求的功能和区别

作业：描述问题自己总结
　　　　　通过tcp套接字发送一个文件给客户端
　　　　　http协议进一步了解





day 03

tcp应用  http服务器

１．接收http请求
２．给出一定的响应

splitlines()按行分割

IO  input output
在内存中存在数据交换的操作
内存和磁盘交换　　文件读写　打印
内存和网络交换　　recv send 

IO密集型程序　：程序执行中执行大量的IO操作，而较少需要cpu运算
特点：消耗cpu资源少，运行周期往往较长

IO分类：
阻塞IO(最基础的)：默认形态　　　是效率最低的一种IO
  阻塞：因为等到某种条件达成再继续运行　比如：　accept  recv  input
       处理IO事件的时候耗时较长也会产生阻塞　比如：文件的读写过程，　网络数据的传输过程
非阻塞IO :通过修改IO对象使其变为非阻塞状态(改变第一种阻塞形态[accept recv input])
　　通常用循环不断来判断阻塞条件，需要消耗更多cpu但是一定程序上提高了IO效率

　　s.setblocking()
　　　　功能：将套接字设置的阻塞状态
　　　　参数：bool默认为True 设置为False则为非阻塞

超时等待(超时检测)

　　cookie
　　　　import traceback(更专业的打印异常信息)
　　　　traceback.print_exc()

　　s.settimeout()
　　　　功能：设置套接字的超时检测
　　　　参数：超时时间
　　　　所谓超时检测 即　对原本阻塞的函数进行设置，使其不再始终阻塞，而是阻塞等待一定时间后自动返回，在规定时间中正常结束阻塞则继续执行否则产生tineout异常

  join()  wain

IO多路复用
  定义：同事监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件，形成并发的效果
  import select

  select的函数：
  select -----> 支持的系统(win linux unix)
  poll--------> 支持的系统(linux unix)
  epoll-------> 支持的系统(linux unix)
  select:
  r,w,x=select(rlist,wlist,xlist,[timeout])
  功能：监控IO事件，阻塞等待IO事件发生
  参数：rlist  列表　　存放我们要处理等待处理的IO  accept  recv
       wlist  列表　　存放我们希望主动处理的IO  send
       xlist  列表　　粗放如果发生异常需要我们处理的IO
       timeout　　数字　　超时检测　　如果不传，默认一直阻塞
　　返回值：r :列表　rlist当中准备就绪的IO
         w :列表　wlist当中准备就绪的IO
         x :列表 xlist当中准备就绪的IO
  IO多路服用注意事项：
  　　１．在处理IO过程中不应该发生死循环(某个IO单独占有服务器)
　　　　２．IO多路复用时单进程程序，是一个并发程序
　　　　３．IO多路复用有较高的IO 执行效率

　　poll
    1.创建poll对象
    p=select.poll()
    2.加入关注的IO
    p.register(s)
    p.unregister(s)  从关注IO中删除
    3.使用poll函数进行监控
    events=p.poll()
    [(fileno,event),(),()]
    功能：阻塞等待register的事件只能有任意准备就绪即返回
    返回值：events  [(fileno,event),(),()]
    4.处理发生的IO事件

    常用的 poll io事件
      POLLEN  POLLOUT  POLLUP  　POLLERR  POLLPRE  POLLVAL
      rlist   wlist    断开连接  xlist    紧急处理  无效数据
    s & POLLIN
　　epoll
    用法和poll相同
    特点：
      *效率上比poll和select稍微高
      *只能用于linux unix
      *支持边缘触发  select poll只支持水平触发

 水平触发:如果文件描述符已经就绪可以非阻塞的执行IO操作了,此时会触发通知.允许在任意时刻重复检测IO的状态,没有必要每次描述符就绪后尽可能多的执行IO.select,poll就属于水平触发.
    边缘触发:如果文件描述符自上次状态改变后有新的IO活动到来,此时会触发通知.在收到一个IO事件通知后要尽可能多的执行IO操作,因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述符.信号驱动式IO就属于边缘触发.
    epoll既可以采用水平触发,也可以采用边缘触发.
    大家可能还不能完全了解这两种模式的区别,我们可以举例说明:一个管道收到了1kb的数据,epoll会立即返回,此时读了512字节数据,然后再次调用epoll.这时如果是水平触发的,epoll会立即返回,因为有数据准备好了.如果是边缘触发的不会立即返回,因为此时虽然有数据可读但是已经触发了一次通知,在这次通知到现在还没有新的数据到来,直到有新的数据到来epoll才会返回,此时老的数据和新的数据都可以读取到(当然是需要这次你尽可能的多读取).
    下面我们还从电子的角度来解释一下:
    水平触发:也就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知.上面提到的只要有数据可读(描述符就绪)那么水平触发的epoll就立即返回.
    边缘触发:只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据可读,但是没有新的IO活动到来,epoll也不会立即返回.

事件驱动IO
异步IO

cpu密集型程序　：程序执行中需要大量的cpu运算，IO操作较少，占用cpu多








作业：
复习tcp udp select http  代码能够自己完成





day04


本地套接字：本地进程间实现通信

本地套接字
　　b(块设备文件)硬件驱动
 　c(字符设备文件)鼠标　键盘 
 　d(文件夹)
　　-(普通文件) 
　　l(链接文件) link
  s(套接字) 
  p(管道文件)
  意义：在linux/unix操作系统下，提供本地进程间通信的一种方式

  本地套接字创建流程:
  　服务端：
    １．创建套接字文件
      创建本地套接字
      sockfd=socket(AF_UNIX,SOCK_STREAM)
    ２．绑定套接字文件
    ３．监听
    ４．接受连接
    ５．消息收发
  cookie:
    os.unlink()  or os.remove()
    功能：删除某个文件
    os.path.exists()
    功能：判断一个文件是否存在
    参数：一个路径文件


多任务编程
　　通过应用程序利用多个计算及核心达到多任务同时执行的目的，以此来提升程序执行效率

多进程，多线程

进程：程序在计算机中一次执行的过程
程序：　是一个静态的描述，不占有计算机资源
进程：　是一个动态的过程，占有cpu内存的计算机资源，有一定的生命周期
*　同一个程序，每次执行都是不同的进程，因为分配的计算机资源不同

　　进程的创建流程
　　　　　用户空间运行程序发起进程创建申请--->　调用操作系统内核接口创建进程--->分配计算机资源，确定进程状态--->　将新的进程提供用户使用　
　　
　　多个进程，如何占用cpu
    *　一个内核同一时刻只能运行一个任务
    * 多个进程对内核资源进行争夺，操作系统决定哪个进程占有计算机核心
    *　占有计算机核心进程我们称为该进程占有cpu的时间片
　　
　　进程有哪些信息，如何保存
　　　　PCB(进程控制块):在unix,linux系统中进程创建后，会在内核开辟一块空间存放进程的相关信息，称为PCB

    查看进程信息　ps -aux
    信息：用户  PID　占有内存　　优先级　等
    PID:在操作系统中进程的唯一标志，是大于0的整数，由系统自动分配
  进程特征
  　　１．进程是操作系统资源分配的最小单位
  　　２．每个进程单独占有4G虚拟内存
  　　３．进程之间相互独立，运行不受影响
　　进程的状态
  　　三态
  　　　　就绪态　：进程具备运行条件，等待系统分配处理器运行
  　　　　运行态　：进程占有cpu处于运行的状态
  　　　　等待态 ：又称为阻塞态，睡眠态，指进程暂时不具备运行的条件，需要阻塞等待(sleep accept...)
　　　　五态
　　　　　　新建态　：创建一个进程，获取资源，直接表现为运行一个程序，或者在程序中创建新的进程
 　　　　　就绪态　：进程具备运行条件，等待系统分配处理器运行
  　　　　运行态　：进程占有cpu处于运行的状态
  　　　　等待态 ：又称为阻塞态，睡眠态，指进程暂时不具备运行的条件，需要阻塞等待(sleep accept...)
　　　　　　终止态　：进程执行结束，资源回收过程

　　ps -aux ---->STAT　表示进程状态
　　　　D 等待态  (不可中断等待)
　　　　S　等待态　　(可中断等待)
　　　　T 等待态　　(暂停)
　　　　R　运行态
    Z　僵尸态　　(死亡状态)

    + 前台进程　(不带+即为后台进程)
    <　高优先级
    N　低优先级
    l　有进程链接
    s　会话组

进程优先级

优先级决定了一个进程的执行权限和占有资源的优先程度

df -h Df命令是linux系统以磁盘分区为单位查看文件系统，可以加上参数查看磁盘剩余空间信息

top  ： 动态查看当前运行的进程的状态  q退出
         < > 可以翻页
  #!/usr/bin/env python3(加env会在top中显示文件名)

  linux 中优先级范围  -20 ---- 19   -20最高
  用户程序默认优先级为0

nice  ： 以指定的优先级运行进程

  e.g.
  nice  -9   ./while.py    以9的优先级运行此程序
  sudo nice  --9 ./while.py  以-9的优先级运行此程序(小于0的优先级一般要加sudo)

renice ： 改变某个进程的优先级

  e.g.    renice  2  PID(NI)

进程（process）
　　父子进程：在系统出除了初始化进程其他进程都有一个父进程，可能有多个子进程。
　　　　
　　　　进程树  pstree

　　　　ps -ajx  显示PPID

　　要求 ： 
　　　　1. 什么是进程，进程的特征
　　　　2. 进程状态，每种状态怎么回事，转换
　　　　3. 进程和线程的区别

　　需求 ： 编写一个程序可以同时做多件事情

　　方案 ： 使用两个进程分别完成预定事件

　　  import os 

　　　　fork()
      多程序：无法根据情况动态创建进程
      通过接口创建进程：便于控制，可以在程序中随时根据需要创建
      

　　  os.fork()
　　  功能 ： 创建一个新的进程
　　  参数 ： 无
　　  返回值 ： 失败返回一个负数  -1
          　　　成功  0   在子进程中fork的返回值  （成功即为创建新的进程成功了）

                　　>0的正整数（新的进程的PID）在父进程中的返回值

* 父进程中fork之前的内容子进程同样会复制，但父子进程空间独立，fork之后的修改不会影响到对方
* 父子进程在执行上互不影响，谁先执行，谁先执行完不确定
* 子进程虽然复制父进程的空间，但是有自己的特性，比如自己的PID，进程PCB，进程栈空间等。

进程相关函数

获取PID号
  os.getpid()
    功能：获取当前进程的PID号
    返回值 ： 当前进程PID

  os.getppid()
    功能 ： 获取当前进程父进程的PID号
    返回值 ： 父进程PID

  进程的退出
    os._exit(status) 
      功能 ： 结束一个进程
      参数 ： 表示进程的结束状态 是一个整数
             带一个下划线的不能被from 　os import * 引用

sys.exit([status])
功能 ： 结束一个进程，抛出异常
参数 ： 传入一个正整数表示结束状态
        传入字符串表示结束打印


孤儿进程 ：父进程先于子进程退出，此时子进程变为孤儿进程

* 孤儿进程会被系统指定的进程所“收养”，即该进程成为孤儿进程新的父进程。在孤儿进程退出时，“继父”会进行处理不会使其成为僵尸


僵尸进程 ： 子进程先于父进程退出，但是父进程没有处理子进程的退出状况，子进程就会成为僵尸进程。

* 僵尸进程会滞留PCB的部分信息在内存中，大量的僵尸进程会消耗系统资源，所以应该尽量避免僵尸进程的产生
      

如何避免僵尸进程的产生
　　让父进程先退出 (不好控制)
  让父进程处理子进程的退出
  　　使用wait 或者 waitpid　函数

  　　　　os.wait()　　阻塞函数，直到子进程退出才会结束阻塞
        功能：等待子进程的退出进行处理
        参数：　无
        返回值：一个二元元组，第一个值为退出的子进程pid
                           第二个值为子进程退出状态
      os.wait(pid,option)
        功能：处理子进程的退出
        参数：pid: -1 ：表示等待任意子进程的退出

                  >0　：表示等待相应的PID号的子进程

            option: 0 :表示阻塞等待

            　　　　　　　　WNOHANG : 表示非阻塞等待 
        返回值：一个二元元组，第一个值为推出的子进程pid
                           第二个值为子进程退出状态

    　　os.waitpid(-1,0)==os.wait()

  　　使用信号处理

  创建二级子进程
  　　父进程创建子进程后等待子进程退出
  　　子进程创建二级子进程后马上退出，二级子进程成为孤儿
  　　让父进程和二级子进程处理具体事件


　　


作业：
学习os.waitpid()的使用
写个群聊聊天室
　　选择使用什么样的套接字
　　功能描述：
　　　　类似于qq群聊，用在加入聊天室时有一个简单的登录　输入用户名即可
　　　　需要个数据结构保存用户　用字典和列表均可
　　　　当一个人发送消息　其他人可以接收消息　
　　　　　　格式：　张三　　xxx
    当一个人登录　退出时给其他人一些提示
    管理员可以发消息　全部在线成员均可收到




day05

群聊聊天室

*选择使用什么样的套接字

udp   

转发 客户端 ---》 服务器  ---》 其他客户端
用print简单打印命令操作提示
存储用户    列表  字典
使用函数或者类来包装功能
没完成一个功能检测一个功能


*功能描述

#类似于qq群聊 ，用户在加入聊天室时有一个简单的登录
输入用户名即可
实现 ： 客户端输入用户名，发送给服务器，服务器存储

#需要个数据结构保存用户
收到发过来的用户名 放到列表或者字典中


#当一个人发送消息 其他人可以接受消息 
  张三 ： xxxxxx
实现 ： 客户将消息发送给服务器，服务器遍历列表，进行转发

#当一个人登录 退出时给其他人一些提示 
 xxx  login
 xxx  logout
实现：给服务器发送登录退出消息，服务器转发

# 管理员发送消息 全部在线成员均可收到
实现 ： 服务端可控制消息发送，给所有人

server:
def login:
def chat:

def main()


    
multiprocessing 模块创建进程  标准库模块
　　需要将事件封装为函数
　　使用multiprocessing提供的类创建新的进程
　　新的进程和对应的函数相关联，进程启动会自动执行函数，完成事件
　　进程回收
　　
　　创建子进程类
　　　　multiprocessing.Process()
    　　功能：创建子进程
    　　参数：name : 给创建的进程起个名字
    　　　　　　　　　　　　　　默认 process-1

           target:目标函数

           args:　　元组　　要给函数传递的参数

           kwargs: 字典　　要给函数传递的参数　　键值
  进程对象属性函数
  　　p.start()
      功能：启动子进程　此时进程真正创建
    p.join([timeout])
      功能：阻塞等待回收相应的子进程
      参数：默认为阻塞，timeout为超时时间
    p的其他属性
    　　p.name 进程名称
    　　p.pid 创建进程的PID号
    　　p.is_alive() 进程状态
    　
    p.daemon
      默认值为False 表示主进程结束后　不影响子进程的执行　如果设置为True 则主进程执行完毕后　所有的子进程一同退出不执行

    　　*设置必须在start()前
    　　*一般使用daemon=True时不用加join
      *该属性并不是linux/unix系统中所说的守护进程设置(只是一个标识位)

  守护进程：生命周期长，随系统创建　　随系统销毁　不受前端控制，后台运行　操作系统进程，或者是自动化运行进程居多


作业：编写一个程序　使用multiorocessing
   要求创建两个进程复制一个文件，各复制一半(以字节来分)

import os
from socket import *
import multiprocessing as mp
f=open('aa.py','rb')
a=os.path.getsize('aa.py')
n=a//2
m=open("aab.txt","wb")
def fun(m):
    m.write(f.read(n))
    m.close()
p=mp.Process(target=fun(m))
p.start()
b=open("abc.txt","wb")
f.seek(n)
b.write(f.read())
f.close()
b.close()
方法二：



day06

waitpid处理僵尸进程
创建二级子进程
注意事项：
先根据功能计划模块，确定技术点
做好整体架构的设计
模块的编写---->模块的测试
发现bug或者进行优化
积累调试经验
multiprocessing
 创建新的进程
 Process---->进程对象p

size=os.path.getsize('文件名')  获取文件的字节
-------------------------------------------------------------------




创建自己的进程类
　　class Parent(object):
　　　　　　固定方法，父类已经实现好了
      def __call__():
          run(1,2,3)

      def run(a,b,c)
          pass

  class Child(Parent):
      def __call__():
          run(1,2,3)

      def run(a,b,c):
          ...
          ...


多进程
　　优点：
　　　　并行多个任务，提供运行效率
　　　　空间独立，数据安全，创建方便
　　缺点：
　　　　进程创建销毁的过程中消耗较多的计算机资源

进程池
  在需要频繁的创建删除较多的情况下，导致计算机资源消耗过多

  进程池如何处理
    创建进程池，在池内放入适量的进程
    将事件加入进程池等待队列
    使用进程池中的进程不断处理事件
    所有事件处理后，回收关闭进程池

  from multiprocessing import Pool

  Pool()
    功能：创建进程池
    参数：procdsses:指定进程池中进城数量
    返回：得到进程池对象
  Poll.apply_async()
    功能：异步方式将事件放入进程池执行
    参数：　func :要执行的事件函数
    　　　　　　args:同Process中args 给函数传参
    　　　　　　kwds:同Process中kwargs 给函数传参
    返回值：返回一个对象　该对象可以通过get()方法得到func函数的返回值

  Pool.close()
    功能：关闭进程池，使其无法加入新的事件

  Pool.join()
  功能：阻塞等待进程池退出(当所有事件处理完毕后)

  Pool.apply()
  　　用法和apply_asnc一样，只是需要顺序执行，一个事件结束再执行另一个事件
  Pool.map(func,iter)
    功能：类似于内建函数map 将第二个参数的迭代数传递给第一个参数的函数执行，同时兼容了使用进程池执行
    返回值：返回func的返回值列表

  r = pool.map(fun,test) 等同于
  r = []
  for i in test:
    res = pool.apply_async(fun,(i,))
    r.append(res.get())


进程间通信
　　磁盘交互
    速度慢
    不安全

  套接字通信socket 本地套接字

  以上两种通常不用

  管道　　消息队列　　共享内存　　信号　　信号量　　套接字
　　
　　管道通信(pipe)
　　　　在内存中开辟一块空间，对多个进程可见，通过管道，多进程进行通信
  multpprocessing---->pipe

  fd1,fd2=Pipe(duplex=True)
    功能：创建一个管道
    参数：duplex 默认为True 表示双向管道
    　　　　　　　　　　　　设置为False 则表示单向管道
    返回值：返回两个管道流对象，表示管道的两端
    　　　　　　　如果是双向管道则两个均可读写
           如果为单向管道则　fd1只能读，fd2只能写

  　　fd1.recv()
      功能：接收消息(每次接受一条)
      参数：无
      返回值：接收消息
      *如果管道没有消息会阻塞


    fd2.send(data)
    　　功能：发送消息  可以是字符串或者是其他类型
    　　参数：要发送的内容
    　　*如果没有接收端则管道破裂

  消息队列
  　　队列：先进先出
  　　　　在内存中开辟队列模型，用来存放消息，任何拥有队列的进程都可以存取消息
  　　创建队列
  　　　　q=Queue(maxsoze=0)
       功能：创建一个消息队列
       参数：maxsize默认为0　表示队列可存放多少消息有内存而定
       　　　　　　　　　　　　　　　　　>0 表示队列最多存放多少条消息
       返回值：返回消息队列对象

      q.put()
        功能：向队列中存放消息

        参数：要存的消息(字符串　　整数　　列表)
        *当队列满时会阻塞
      q.full()
        判断队列是否为满　　满返回True
      q.get()
        功能：向队列中取出消息
        返回值：取出的消息
        *当队列满时会阻塞 
      q.empty()
        判断队列是否为空 空返回 True 
      q.qsize()
      　　得到当前队列中消息的个数
      q.close() 关闭队列
      *put get 中均有可选参数 block 和timeout  block 默认为True 表示阻塞函数　如设置为False则不阻塞
      timeout block 为True时设置超时时间 

  共享内存
  　　在内存中开辟一段空间　，存储数据，对多个进程可见，每次写入共享　内存的数据会覆盖之前的内容，由于对内存格式化较少，所以存取速度快 
    只能存储一条消息

  　　from multiprocessing import Vale,Array 
  　　　　obj=Value(ctype,obj)
        功能：开辟内存空间
        参数：ctype str 要转变的c类型 (只接受c语言) (对照ctype表)
         　　　　obj 写入共享内存的初始值
  　　　　　　返回值：返回一个共享内存对象
  　　　　　　obj.value　即可得到共享内存中的值
  　　　　obj=Array(ctype,obj)
        功能：开辟共享内存空间
        参数：ctype 要转换的类型
        　　　　　obj  存入到共享内存的数据
        　　　　　　　　　　是一个列表，要求列表中数类型一致
        　　　　　　　　　　正整数，则表示开辟一个多大的序列空间

      　　返回值：返回一个共享内存对象

进程间通信的对比：

  　　　　　　　　管道　　　　　　　　　　　　　消息队列　　　　　　　　　　共享内存
_________________________________________________________
开辟空间　　　内存　　　　　　　　　　　　　　　内存　　　　　　　　　　　　内存
_________________________________________________________
读写方式　　双向/单向　　　　　　　　　　先进先出　　　　　　　　　　操作覆盖内存
____________________________________________________________
效率　　　　　　　一般　　　　　　　　　　　　　　　一般　　　　　　　　　　　　较快
__________________________________________________________
应用　　　　　　多用于亲缘进程　　　　　　　方便灵活广泛　　　　　较复杂
_____________________________________________________________
是否需要　　　　是　　　　　　　　　　　　　　　　　否　　　　　　　　　　　　　需要
互斥机制





信号
　　一个进程向另一个进程通过信号传递某种讯息

  kill -l 查看信息
  kill -signame PID  给PID的进程发送一个信号

  信号的名称　　：系统定义，信号的名字
  信号的含义　　：系统定义的，信号的作用
  信号的默认处理方法　　：系统定义的，信号给接受进程带来的行为一般有　终止　暂停　忽略

  python 如何处理
  　　发送
  　　　　os.kill(pid,sig)
        功能：向一个进程发送一个信号
        参数： pid:要发送信号的进程PID
              sig:要发送的信号
      signal.alarm(sec)
        功能：向自身发送一个时钟信号　SIGALRM
        参数：sec 时钟秒数
  *信号属于异步通信方式，信号的发送不会影响进程的持续执行
  *一个进程中只能同时有一个时钟，后面的时钟时间会覆盖前面的时钟时间

  　　处理
      signal.pause()
        功能：阻塞等待一个信号的发生
    　　　　　　　
作业：
对进程间通信进行描述连接
熟悉进程间通信代码







day07



信号处理
　　import signal

　　signal.signal(signum,handler)
    功能：　处理一个信号
    参数：　signum:　要处理的信号

    　　　　　　handler: 对该信号的处理方法
    　　　　　　　　　　　　　　取值：SIG_DFL　采用默认方法处理(等同于默认为signum)
    　　　　　　　　　　　　　　　　　　　SIG_IGN 忽略这个信号
    　　　　　　　　　　　　　　　　　　　func自己定义的方法处理（回调函数把一个函数当成参数传递过去）　
                   func　格式要求：
                   　　　def func(sig,frame):
                          ...
                      sig:接收到的信号
                      frame:信号对象

  *signal函数是一个异步处理信号函数，只要执行，在进程中就会按照指定方法处理信号
  *signal不能处理SIGSTOP SIGKILL信号

  信号量
    给定一定的信号数量，对多个进程可见，并且多个进程均可操作，进程根据信号量的多少，可以有不同的行为

    multiprocess------->Semaphore()
    Semaphore(num)
      功能：定义信号量
      参数：num : 给定信号量的初始个数
      返回值：返回信号量对象

      sem=Semaphore(num)
      　　sem.acquire() 将信号量　减一　信号量为0时调用会阻塞

      　　sem.release() 将信号量　加一

    cookie:
      获取当前进程对象：
      　　multiprocessing.current_process()
  　　
  　　使用处理僵尸进程
  　　　　在父进程中,忽略子进程的发送信号
  　　　　　　signal(SIGCHLD,SIG_IGH)

同步和互斥
　　目的：对共有资源的操作会产生争夺，同步和互斥时一种解决争夺的方案
　　临界资源：多个进程或者线程都可以操作的资源
　　临界区：　操作临界资源的代码段
　　同步：同步是一种合作关系，为完成某个任务多进程或多线程之间形成一种协调，按照条件次序执行，传递告知资源情况，这种协调可能是因为阻塞关系达成的
　　互斥：互斥是一种制约关系，但一个进程或线程进入到临界区会进行加锁操作，此时其他进程(线程)在企图操作临界资源就会阻塞，只有当资源被释放才能进行操作

　　Event事件
　　  创建事件对象
　　　　　e=Event()
    提供事件阻塞
     e.wait()
    对事件对象进程设置，此时e.wait判断事件被set则结束阻塞
    　e.set()
    清除该事件对象的set
    　e.clear()
    检测对象是否被设置　设置返回True
     e.is_set()

  Lock 锁
  　　multiprocessing------>Lock
    创建一个对象：
      lock=Lock()
    上锁
      lock.acquire()
    解锁
      lock.release()
    with Lock  :------>给wait代码段上锁
      ...
      ...
    -------------------->with代码段结束自动解锁
    *在lock对象处于上锁状态的时候，在企图上锁则会阻塞直至锁被释放，才会继续执行上锁操作



线程
　　*线程也是多任务编程的一种方法，可以使用计算机多核资源
　　*线程又称为轻量级的进程，在创建和删除时消耗的计算机资源小

　　线程和进程关系：
　　　　*一个进程中可以包含多个线程
　　　　*进程中的所有线程共享进程的空间资源(空间，全局变量，分配的内存等)
    *线程也有自己的特有属性，比如：指令集　TID等

  创建线程
  　　import threading 
      t=threading.Tread()
      Thread()
        功能：创建线程
        参数：target 线程函数
        　　　　　　args  　元组　给线程函数位置传参
        　　　　　　kwargs　字典　给线程函数字典传参
        　　　　　　name 　　给线程取名字　　(默认Thread-1)
        返回值：线程对象　

      t.start() 启动线程
      t.join(timeout) 回收线程
      t.is_alive() 查看线程状态
      t.name 查看线程名称
      threading.currentThread() 得到线程对象
      t.setName() 设置属性名称
      t.daemon 属性
      默认为False 主线程执行完毕不会影响分支线程的执行
      　　设为True 主线程执行完毕，其他线程也会终止

      t.isDaemon():判断　deamon属性时True or False


      设置方法：
      　　t.daemon=True
        t.setDaemon(True)
　　线程间通信
　　　　通过全局变量进行通信

　　　　进程和线程的区别和联系
　　　　　　两者都是多任务编程方式，均可使用计算机的多核
　　　　　　进程的创建要比线程消耗更多的资源
　　　　　　进程空间独立，数据安全性更好操作，有专门的进程间通信方式
　　　　　　线程使用全局变量通信，往往要和同步互斥机制配合防止产生资源的争夺
　　　　　　一个进程可以包含多个线程，线程共享进程资源
　　　　　　进程线程都有自己的特有资源

　　　　使用场景
　　　　　　需要创建较多的并发，任务比较简单，线程比较合适
　　　　　　如果程序间数据资源使用重叠比较多，要考虑到线程锁是否需要更复杂的逻辑
　　　　　　如果多个任务并无什么关联，不易用多线程将其融入到一个进程中
　　　　　　python线程不适用计算密集型并发

　　创建自定义线程类
　　　　继承Thread类
　　　　重写　run　方法
    from threading import Thread
    from time import ctime,sleep
    
    #编写自己的线程类
    class Mythread(Thread):
        def __init__(self,func,args,name='Tedu'):
            # Thread.__init__(self)
            super().__init__()
            self.func=func
            self.args=args
            self.name=name
        #调用start会自动运行
        def run(self):
            self.func(*self.args)
    def player(file,sec):
        for i in range(2):
            print("playing %s :%s"%(file,ctime()))
            sleep(sec)
    t=Mythread(player,('baby.mp3',3))
    t.start()
    t.join()

  线程中同步互斥方法
  　　Event　线程事件
      e=Event()
        e.wait()  e.set()  e.clear()

    Lock  线程锁
    　　t=Loce() 创建锁
    　　　　t.acquire() 加锁
    　　　　t.release() 解锁


    Condition

  

作业 : 
信号通信 
司机和售票员的故事
1. 创建父子进程，分别表示司机和售票员
2. 当售票员捕捉到 SIGINT信号时 给司机发送 SIGUSER1信号， 此时司机打印 “老司机开车了”
   当售票员捕捉到  SIGQUIT时 给司机发送 SIGUSER2信号，此时司机打印“系好安全带，车速有点快”
   当司机捕捉到 SIGTSTP时，发送SIGUSER1给售票员，售票员打印 “到站了，请下车”
3. 到站后 售票员先下车（子进程退出）,然后司机下车
from multiprocessing import *
import os,time
from signal import *
def fun1(sig,frame):
    if sig==SIGINT:
        os.kill(os.getppid(),SIGUSR1)
    elif sig==SIGQUIT:
        os.kill(os.getppid(),SIGUSR2)
    elif sig==SIGUSR1:
        print("到站了，请下车")
        os._exit(0)
def fun2(sig,format):
    if sig==SIGUSR1:
        print("老司机开车了")
    elif sig==SIGUSR2:
        print("系好安全带")
    elif sig==SIGTSTP:
        os.kill(p.pid,SIGUSR1)
#售货员
def fun():
    signal(SIGINT,fun1)
    signal(SIGQUIT,fun1)
    signal(SIGUSR1,fun1)
    signal(SIGTSTP,SIG_IGN)
    while True:
        time.sleep(1)
        print("带你飞")
p=Process(target=fun)
p.start()
signal(SIGUSR1,fun2)
signal(SIGUSR2,fun2)
signal(SIGTSTP,fun2)
signal(SIGINT,SIG_IGN)
signal(SIGQUIT,SIG_IGN)
p.join() 

温馨提示 ： 键盘发送信号会给终端所有进程


TFTP文件服务器

文件的上传，下载，和服务端文件库的查看

服务端       客户端
             1.查看文件库中有哪些文件
             2.下载文件到本地
             3.将本地的文件上传到文件库
　　　　　　　　　　　
　　　　

day08

内核：操作系统的核心代码

并发：同时处理多个任务的请求，但是内核采用轮训事件片的方式逐个访问，某个时间点实际只处理一个任务
比如：　IO多路复用　　协程　　循环服务器　　单线程

并行：使用多个内核，同时执行多个任务
比如：　多线程　　多进程
　　计算机原理　　算法导论
公众号：python程序员　　python开发者　　 app : 掘金
===================================================================

条件变量　　condition
  创建条件变量对象
  　　con=threading.Condition()

    con.acqire()：对资源加锁,加锁后其他位置再加锁则阻塞

    con.release()：解锁
    con.wait():wait函数只能在加锁的状态下使用。wait函数会先解锁(release)，然后让线程处于等待通知的阻塞状态

    con.notify():发送通知，线程接收到通知后，结束wait阻塞，并且执行acquire加锁操作

threadpool 第三方模块

python线程之GIL
(全局解释器锁)
python ---->支持多线程---->同步互斥---->加锁--->超级锁--->在同一时刻，解释器只能解释一个线程---->大量python库为了省事沿用了这种方法--->python 多线程效率低下
GIL问题:由于python的全局解释器锁造成python的多效率执行效率低下
解决方法：
*不使用线程，使用多进程
*不适用C C++ 做解释器　　　　　C#  Java也可以做解释器
*python线程适合高用时的IO操作，网络IO,不适合cpu密集型程序
 


设计模式
　　设计模式代表了一种最佳实践，是被开发人员长期总结，用来解决某一类问题的思路方法，这些方法保证了代码的效率也已于理解

单例模式　　工厂模式　　生产模式......

生产者消费者

控制数据资源数量
降低耦合度

多个消费者　消耗
多个生产者　生产
均对仓库资源进行操作

总结
　　进程线程区别和联系
　　同步互斥的意义和是实现方法
　　进程线程使用什么样的方式通信
　　进程线程的特点和选择
　　简单的设计模式的理解
　　僵尸进程，进程状态，GIL等概念的理解

服务器模型
　　硬件服务器：主机　　集群
　　　　厂家：　IBM  HP
  软件服务器：网络服务器　　：在后台提供网络功能，逻辑处理，数据处理的程序或者架构等
  　　例如：httpserver   django  flask

  服务器模型：c/s(客户端服务器)  b/s(浏览器服务器)  服务器的组织形式

  服务器追求：处理速度快，数据更安全，并发量大

  硬件：　更高配置，　　更多主机，　集成，　分布
  软件：　程序占有更少的资源，更流畅的运行，处理更多的并发

　　基本的服务器模型
  　并发：循环　　并发模式　　IO多路复用
  　　　循环：单线程程序，循环接受连接或者请求，然后处理，处理后继续循环
  　　　　　缺点：不能同时处理多个客户端的并发，不允许某个客户端占有服务器
  　　　　　特点：结构比较简单，适用于udp程序，要求处理请求可以很快完成
　　　　　IO多路复用模型
　　　　　　通过同时监控多个IO来达到IO并发的目的
　　　　　　缺点：也是单线程，不能长期阻塞　　不适合处理大量cpu占有高的程序
　　　　　　优点：开销小，比较适合IO密集型的服务端程序　
　　　　并行服务器：每有一个客户端链接请求，就创建一个新的进程或者线程处理客户端的请求，而主进程/主线程可以继续接受其他客户端的连接
　　　　　　缺点：资源消耗比较大
　　　　　　特点：客户单需要长期占有服务器的情况
　　　　　基于fork的多进程并发
　　　　　　　先创建套接字　绑定　　监听
　　　　　　　接收客户端请求
　　　　　　　创建子进程处理客户端请求，父进程继续准本接受新的客户端连接
　　　　　　　如果要是客户端推出，销毁相应的子进程
　　　

  　　
TFTP文件服务器

文件的上传，下载，和服务端文件库的查看

服务端       客户端
             1.查看文件库中有哪些文件
             2.下载文件到本地
             3.将本地的文件上传到文件库

确定技术：
fork-----多进程
tcp socket

os.listdir(path)
　　获取该文件夹下所有文件，形成一个列表
os.path.isfile(path)
os.path.isdir(path)
  判断文件是否为普通文件/文件夹




day09


多线程并发


相比多进程并发：
劣势：１．可能需要同步和互斥的机制
　　　　　２．受到GIL的影响
优势：　只需要消耗较少的系统资源
实现：
threading 模块完成
步骤：
１．创建套接字
２．准备接收客户端连接
３．每当有一个客户端链接进来就创建一个新的线程
４．客户端退出后结束相应线程，关闭客户端套接字


基于多线程的HttpServer


思路：每有一个客户端就用一个线程为其服务
　　　　　httpserver的功能(解析请求和处理响应)封装成类
　　　　　所有的静态页面收集到一个文件夹
　　　　　处理方法放在一个文件夹
　　　　　
技术实现：
并发：多线程
server类的设计：
初始化：将socket返回值变为属性，并且增加一系列其他属性
服务器启动方法：接受客户端连接请求，创建新的线程
客户端处理函数：hanleRrequest


cookie:
sys.path:是一个列表，可以添加路径，该python下列表中的路径　，对python下的所有环境可见
__import__():参数为一个目录，等同于import导入



使用集成模块完成网络并发

python3-----> socketserve 模块


进程tcp并发 'ForkingMixIn','TCPServer','StreamRequestHandler'

进程udp并发
'ForkingMixIn' 'UDPServer','DatagramRequestHandler',

线程tcp并发
'ThreadingMixIn' 'TCPServer','StreamRequestHandler'

线程udp并发
'ThreadingMixIn', 'UDPServer','DatagramRequestHandler',

'ForkingTCPServer',
 'ForkingUDPServer',
 'ThreadingTCPServer',
 'ThreadingUDPServer',

 拓展：

进程 线程和协程的区别:

 首先我们来了解下python中的进程，线程以及协程！
从计算机硬件角度：
计算机的核心是CPU，承担了所有的计算任务。
一个CPU，在一个时间切片里只能运行一个程序。
 
从操作系统的角度：
进程和线程，都是一种CPU的执行单元。
进程：表示一个程序的上下文执行活动（打开、执行、保存...）
线程：进程执行程序时候的最小调度单位（执行a，执行b...)
一个程序至少有一个进程，一个进程至少有一个线程。
 
并行 和 并发：

并行：多个CPU核心，不同的程序就分配给不同的CPU来运行。可以让多个程序同时执行。
cpu1 -------------
cpu2 -------------
cpu3 -------------
cpu4 -------------
并发：单个CPU核心，在一个时间切片里一次只能运行一个程序，如果需要运行多个程序，则串行执行。
cpu1　　----　　----
cpu1 　　　----　　----
 

多进程/多线程：
表示可以同时执行多个任务，进程和线程的调度是由操作系统自动完成。

进程：每个进程都有自己独立的内存空间，不同进程之间的内存空间不共享。
进程之间的通信有操作系统传递，导致通讯效率低，切换开销大。
线程：一个进程可以有多个线程，所有线程共享进程的内存空间，通讯效率高，切换开销小。
共享意味着竞争，导致数据不安全，为了保护内存空间的数据安全，引入"互斥锁"。
一个线程在访问内存空间的时候，其他线程不允许访问，必须等待之前的线程访问结束，才能使用这个内存空间。
互斥锁：一种安全有序的让多个线程访问内存空间的机制。
 
Python的多线程：
GIL 全局解释器锁：线程的执行权限，在Python的进程里只有一个GIL。
一个线程需要执行任务，必须获取GIL。
好处：直接杜绝了多个线程访问内存空间的安全问题。
坏处：Python的多线程不是真正多线程，不能充分利用多核CPU的资源。
但是，在I/O阻塞的时候，解释器会释放GIL。

所以：
多进程：密集CPU任务，需要充分使用多核CPU资源（服务器，大量的并行计算）的时候，用多进程。 multiprocessing
缺陷：多个进程之间通信成本高，切换开销大。

多线程：密集I/O任务（网络I/O，磁盘I/O，数据库I/O）使用多线程合适。
threading.Thread、multiprocessing.dummy
缺陷：同一个时间切片只能运行一个线程，不能做到高并行，但是可以做到高并发。

协程：又称微线程，在单线程上执行多个任务，用函数切换，开销极小。不通过操作系统调度，没有进程、线程的切换开销。genvent，monkey.patchall
多线程请求返回是无序的，那个线程有数据返回就处理那个线程，而协程返回的数据是有序的。
缺陷：单线程执行，处理密集CPU和本地磁盘IO的时候，性能较低。处理网络I/O性能还是比较高.



下面以这个网站为例，采用三种方式爬取。爬取前250名的电影。。
https://movie.douban.com/top250?start=0
 通过分析网页发现第2页的url start=25，第3页的url start=50,第3页的start=75。因此可以得出这个网站每一页的数局是通过递增start这个参数获取的。
一般不看第一页的数据，第一页的没有参考价值。

 
这次我们主要爬取，电影名字跟评分。只是使用不同方式去对比下不同点，所以数据方面就不过多提取或者保存。只是简单的将其爬取下打印出来看看。

第一：采用多进程 , multiprocessing 模块。 当然这个耗时更网络好坏有关。在全部要请求都正常的情况下耗时15s多。
 
 
 
采用多线程时，耗时10.4s
 

 
 
采用协程爬取，耗时15S，
 gevent
 
 
 
 
用了多进程，多线程，协程，实现的代码都一样，没有测试出明显的那个好！都不分上下，可能跟网络，或者服务器配置有关。
但理论上来说线程，协程在I/O密集的操作性能是要高于进程的